<html><body><canvas></canvas><script>var vert=`#version 100

attribute vec4 p;

void main(void) {
    gl_Position = p;
}
`
var frag=`#version 100

precision mediump float;

uniform float t;
uniform vec2 r;

float time = t;
vec2 resolution = r;


#define PI 3.141592
#define TAU 6.28318

float surface(float d, float s) {
    return 1. + 0.05 * sin(d*400.*(1.+s));
}

float arm(vec2 pixel, vec2 krakenPos, float direction, float len, float waviness) {
  
  vec2 delta = pixel - krakenPos;
  float l = length(delta);
  float a = atan(delta.y, delta.x);

  // Wave
  direction += cos(l * 13. - time * 2.) * waviness;
  
  float baseSize = 1.0;
  return (mod(abs(mod(a+TAU/4., TAU) - mod(direction, TAU)), TAU) - (len - l)*baseSize) / 5.;
}

float kraken(vec2 pixel, vec2 krakenPos) {
  float krakenSize = 0.2 + cos(time*1.7)*0.02;
  float b = distance(krakenPos, pixel) - krakenSize;
  //if (b <= 0.) return b;
	
  float arms = 8.0;  
  float dist = b;	
  for (int i = 1; i < 9; i++) {
    dist = min(dist, arm(pixel, krakenPos, float(i) * TAU / arms - time/3., 0.5, .1));
  }
  return dist;
}

float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

void main( void )
{
  vec2 pos = (gl_FragCoord.xy * 2.0 - resolution)/max(resolution.x, resolution.y);
  float wave = 0.0;

  // Sky color by default
  vec3 c = mix(vec3(.7, 0.9,0.8), vec3(.4, .6,.9), pos.y+0.5);
  c *= 1. + 0.3 * surface(pos.y, 3.-pos.y*3.);	
	
  for (int j = 1; j <= 15; j+=1) {	
    float i = float(j);
	  float x = rand(vec2(i, i+1.0));
	  float wavephase = 2.0*x*13.3*PI+i;
	  //float wavephase = 0.0;
	  float t1 = time*(6.-i*.1);	
	  float wavetime = 0.0;
	  float waveSize = 0.025;
	  float waveAmp = max(0.0,waveSize - i*0.0016);
	
	  float k = 2.0*PI/waveSize;
	  float waveshort = 5.0+i;	
	  float wavestokes = ((1.0-1.0/16.0*pow((k*waveSize),2.0))*cos(pos.x*waveshort+t1+wavephase) + 0.5*k*waveSize*cos(2.0*waveshort*pos.x+t1+wavephase));
	  
	  float wave = waveAmp*pow(wavestokes,1.0)+sin(t1+x*12.2)*0.01/i+(i*(0.06-i*0.0009)-0.5);	 
	  
	  if (j > 4) {
              float kr = kraken(pos, vec2(0.0, -0.2));
		  if (kr < 0.0) {
			  c = vec3(0.1+kr*2., 0.4-kr*0.5, 0.3+kr);
			  c *= surface(kr, .5);  
        break;
		  }      
	  }
	  if (pos.y < wave) {
            c = mix(vec3(0.0,0.1,0.2), vec3(0.6, 0.6+i/60., 0.9), 0.05*i);
	    c *= surface(pos.y - wave, i/8.);  
      break;
	  }
  }

//  if (visibleWave > 0.) c = mix(vec3(0.0,0.1,0.2), vec3(0.6, 0.75, 0.9), visibleWave);

  //c.g = visibleWave / 1.0;
	
  gl_FragColor = vec4(c, 1.0);

}



`
"use strict";

// Constants
var startTime = new Date().getTime();
var TAU = Math.PI * 2;

// Seconds since start of demo
var t = 0;

// Setup canvas
var canvas = document.querySelector('canvas');
canvas.style.position = "fixed";
canvas.style.left = canvas.style.top = 0;
canvas.style.cursor = "none";
// canvas.width = window.innerWidth;
// canvas.height = window.innerHeight;
//canvas.width = 1366; //1920;
//canvas.height = 768; //1080;



// Setup openGL

var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
//var h = gl.drawingBufferHeight;
//var w = gl.drawingBufferWidth;

var pid = gl.createProgram();
shader(gl.VERTEX_SHADER, vert);
shader(gl.FRAGMENT_SHADER, frag);
gl.linkProgram(pid);
gl.useProgram(pid);

var array = new Float32Array([-1, 3, -1, -1, 3, -1]);
gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);

var pos = gl.getAttribLocation(pid, "p");
gl.vertexAttribPointer(pos, 2 /*components per vertex */, gl.FLOAT, false, 0, 0);
gl.enableVertexAttribArray(pos);

var timeLoc = gl.getUniformLocation(pid, 't'); // Time
var resLoc = gl.getUniformLocation(pid, 'r');  // Resolution

// Sound
var ac = new (window.AudioContext || window.webkitAudioContext);

// Brown noise
var bufferSize = 4096;
var lastOut = 0.0;
var bn = ac.createScriptProcessor(bufferSize, 1, 1);
bn.onaudioprocess = function(e) {
  var output = e.outputBuffer.getChannelData(0);
  for (var i = 0; i < bufferSize; i++) {
      var white = (Math.random() * 2 - 1);
      output[i] = (lastOut + (0.02 * white)) / 1.02;
      lastOut = output[i];
      output[i] *= 3.5; // (roughly) compensate for gain
  }
}

// Volume control for waves
var g = ac.createGain();
bn.connect(g);
g.connect(ac.destination);


// Draw a frame, also updates sounds
function draw() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  var h = gl.drawingBufferHeight;
  var w = gl.drawingBufferWidth;

  // Update time (seconds since start of demo)
  t = (new Date().getTime() - startTime) * 0.001;

  // Draw OpenGL scene 
  gl.uniform2f(resLoc, w, h);
  gl.uniform1f(timeLoc, t);
  gl.viewport(0, 0, w, h);
  gl.clearColor(0, 0, 0, 0);
  gl.drawArrays(gl.TRIANGLES, 0, 3);

  // Sea sound
  var vol= 0.2 + wave(2.7)*0.15 + wave(7.3, 2)*0.3; // Waves
  vol *= Math.min(t/9, 1); // Fade in
  g.gain.value = vol

  // Have another frame later
  requestAnimationFrame(draw);
}


// Utility function for compiling a shader.  NOTE: Uses global variable pid (shader program ID).
function shader(type, src) {
  var sid = gl.createShader(type);
  gl.shaderSource(sid, src);
  gl.compileShader(sid);

  // For debugging:
  if (!gl.getShaderParameter(sid, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(sid));
  
  gl.attachShader(pid, sid);
}


/**
 * Utility method for scaled sine waves, starts at 0 at time t=0, phase is added to time parameter.
 * NOTE: Uses global variable t (time).
 * @param {number} waveLength duration of complete wave (up - down - back) in seconds.
 * @param {number} phase Seconds to transition start of wave.
 */
function wave(waveLength, phase) {
  return -Math.sin((t+(phase||0))*TAU/waveLength)/2 + 0.5;
}

// Start demo animation by calling draw
draw();

</script></body></html>